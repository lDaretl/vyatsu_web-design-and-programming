import { C as CursorPosition } from "../cursor.mjs";
const parseTokens = (format) => {
  return format.split("").map((char) => {
    if (char === "m" || char === "d" || char === "y") {
      return { static: false, expect: char };
    }
    return { static: true, expect: char };
  });
};
const getFebMaxDays = (year) => {
  if (Number.isNaN(year)) {
    return 29;
  }
  return year % 4 === 0 ? 29 : 28;
};
const getMaxDays = (year, month) => {
  if (Number.isNaN(month)) {
    return 31;
  }
  if (month === 2) {
    return getFebMaxDays(year);
  }
  if ([4, 6, 9, 11].includes(month)) {
    return 30;
  }
  return 31;
};
const removeStaticCharsFromEnd = (tokens) => {
  let i = tokens.length - 1;
  while (tokens[i] && tokens[i].static) {
    i--;
  }
  return tokens.slice(0, i + 1);
};
const createDateMask = (format = "yyyy/mm/dd") => {
  const tokens = parseTokens(format);
  const cache = /* @__PURE__ */ new Map();
  return {
    format(text) {
      const minorTokens = [];
      let valueOffset = 0;
      let tokenOffset = 0;
      for (let i = 0; i < tokens.length; i++) {
        const token = tokens[tokenOffset];
        if (token.static) {
          minorTokens.push({ value: token.expect, expect: token.expect, static: true });
          tokenOffset++;
          if (token.expect === text[valueOffset]) {
            valueOffset++;
          }
          continue;
        }
        if (text[valueOffset] === void 0) {
          break;
        }
        if (!/\d/.test(text[valueOffset])) {
          const nextTokensHasStatic = tokens.slice(tokenOffset, text.length).some((t) => t.static);
          if (nextTokensHasStatic) {
            tokenOffset++;
          } else {
            valueOffset++;
          }
          continue;
        }
        minorTokens.push({ value: text[valueOffset], expect: token.expect, static: false });
        valueOffset++;
        tokenOffset++;
      }
      const majorTokens = removeStaticCharsFromEnd(minorTokens).reduce((acc, p, index) => {
        var _a;
        if (((_a = acc[acc.length - 1]) == null ? void 0 : _a.expect) === p.expect) {
          acc[acc.length - 1].value += p.value;
          acc[acc.length - 1].tree.push(p);
          return acc;
        }
        acc.push({
          value: p.value,
          expect: p.expect,
          tree: [p]
        });
        return acc;
      }, []);
      majorTokens.forEach((t, index, array) => {
        if (t.expect === "m") {
          const num = parseInt(t.value);
          if (num > 12) {
            t.value = "12";
            t.tree[0].static = true;
            t.tree[1].static = false;
          }
          if (num < 1 && t.value.length === 2) {
            t.value = "01";
            t.tree[0].static = true;
            t.tree[1].static = false;
          }
          if (num > 1 && num < 10 && t.value.length === 1) {
            t.value = "0" + num;
            t.tree.unshift({ value: "0", expect: "m", static: true });
            t.tree[1].static = false;
          }
        }
        if (t.expect === "d") {
          const year = majorTokens.find((t2) => t2.expect === "y" && t2.used === void 0);
          const month = majorTokens.find((t2) => t2.expect === "m" && t2.used === void 0);
          if (year) {
            year.used = true;
          }
          if (month) {
            month.used = true;
          }
          const m = Number(month == null ? void 0 : month.value);
          const maxDays = getMaxDays(Number(year == null ? void 0 : year.value), m);
          if (m === 2) {
            if (Number(t.value) >= 29) {
              t.value = "29";
            }
            if (t.value === "28" && cache.get(index) === "29") {
              t.value = "29";
            }
            cache.set(index, t.value);
          }
          const num = parseInt(t.value);
          if (num > maxDays && t.value.length === 2) {
            t.value = maxDays.toString();
            t.tree[0].static = true;
            t.tree[1].static = false;
          }
          if (num < 1 && t.value.length === 2) {
            t.value = "01";
            t.tree[0].static = true;
            t.tree[1].static = false;
          }
          if (num > 3 && num < 10 && t.value.length === 1) {
            t.value = "0" + num;
            t.tree.unshift({ value: "0", expect: "d", static: true });
            t.tree[1].static = false;
          }
        }
      });
      const newText = majorTokens.reduce((acc, p) => acc + p.value, "");
      const newTokens = tokens.map((t) => ({
        ...t,
        static: false
      }));
      return {
        text: newText,
        tokens: newTokens,
        data: majorTokens.reduce((acc, p) => acc.concat(p.tree), [])
      };
    },
    handleCursor(cursorStart, cursorEnd, oldTokens, newTokens, data, minorTokens) {
      cursorStart.updateTokens(minorTokens);
      cursorEnd.updateTokens(minorTokens);
      cursorStart.moveForward(data.length, CursorPosition.AfterChar);
      cursorEnd.position = cursorStart.position;
    },
    unformat: (text, tokens2) => {
      return text.replace(/\//g, "");
    }
  };
};
export {
  createDateMask as c
};
//# sourceMappingURL=date.mjs.map
