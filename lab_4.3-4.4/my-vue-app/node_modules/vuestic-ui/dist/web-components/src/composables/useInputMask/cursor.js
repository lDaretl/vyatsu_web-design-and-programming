var CursorPosition = /* @__PURE__ */ ((CursorPosition2) => {
  CursorPosition2[CursorPosition2["BeforeChar"] = -1] = "BeforeChar";
  CursorPosition2[CursorPosition2["Any"] = 0] = "Any";
  CursorPosition2[CursorPosition2["AfterChar"] = 1] = "AfterChar";
  return CursorPosition2;
})(CursorPosition || {});
class Cursor extends Number {
  constructor(position, tokens, reversed = false) {
    super(position);
    this.position = position;
    this.tokens = tokens;
    this.reversed = reversed;
  }
  move(direction, amount, cursorPosition = 0) {
    if (this.tokens.every((t) => t.static)) {
      if (direction === 1) {
        this.position = this.tokens.length;
        return this.position;
      } else {
        this.position = 0;
        return this.position;
      }
    }
    for (let i = this.position; i <= this.tokens.length && i >= -1; i += direction) {
      const current = this.tokens[i];
      const next = this.tokens[i + direction] || void 0;
      this.tokens[i - direction] || void 0;
      if (amount === 0) {
        this.position = i;
        return this.position;
      }
      if (next === void 0 && current === void 0) {
        this.position = i;
        return this.position;
      }
      if (cursorPosition === 1) {
        if (current && !current.static && direction > 0) {
          amount--;
          continue;
        }
        if (!(next == null ? void 0 : next.static) && direction < 0 && i !== this.position) {
          amount--;
          if (amount === 0) {
            this.position = i;
            return this.position;
          }
          continue;
        }
      }
      if (cursorPosition === -1) {
        if (!(next == null ? void 0 : next.static)) {
          amount--;
          continue;
        }
      }
      if (cursorPosition === 0) {
        if ((!(current == null ? void 0 : current.static) || !(next == null ? void 0 : next.static)) && direction > 0) {
          amount--;
          continue;
        }
        if (direction < 0) {
          if (next && !next.static) {
            amount--;
            if (i !== this.position) {
              this.position = i;
              return this.position;
            }
          }
        }
      }
    }
    return this.position;
  }
  moveBack(amount, cursorPosition = 0) {
    return this.move(-1, amount, cursorPosition);
  }
  moveForward(amount, cursorPosition = 0) {
    return this.move(1, amount, cursorPosition);
  }
  updateTokens(newTokens, fromEnd = false) {
    if (fromEnd) {
      this.position = this.tokens.length - this.position;
      this.tokens = newTokens;
      this.position = this.tokens.length - this.position;
    } else {
      this.tokens = newTokens;
    }
  }
  valueOf() {
    if (this.position < 0) {
      return 0;
    }
    if (this.position > this.tokens.length) {
      return this.tokens.length;
    }
    return this.position;
  }
}
export {
  CursorPosition as C,
  Cursor as a
};
//# sourceMappingURL=cursor.js.map
