import { c as createRegexMask } from "./regex.js";
const createNumeralMask = (options = {}) => {
  const intMask = createRegexMask(/(\d{3} )*(\d{3})/, { reverse: true });
  const { decimal = true, decimalChar = "." } = options;
  const decimalRegex = new RegExp(`[.|,|${decimalChar}]`, "g");
  if (!decimal) {
    return intMask;
  }
  const decimalMask = createRegexMask(/(\d{3} )*(\d{3})/, { reverse: false });
  return {
    format: (text) => {
      const foundDecimal = text.match(decimalRegex);
      if (!foundDecimal) {
        return intMask.format(text);
      }
      const [int = "", decimal2 = "", ...rest] = text.split(foundDecimal[0]);
      const intResult = intMask.format(int);
      const decimalResult = decimalMask.format(decimal2 + rest.join(""));
      return {
        text: intResult.text + decimalChar + decimalResult.text,
        tokens: [...intResult.tokens, { type: "char", static: false, expect: decimalChar, isDecimal: true }, ...decimalResult.tokens]
      };
    },
    handleCursor(selectionStart, selectionEnd, oldTokens, newTokens, data) {
      const decimalIndex = newTokens.findIndex((token) => token.isDecimal);
      if (decimalIndex === -1) {
        return intMask.handleCursor(selectionStart, selectionEnd, oldTokens, newTokens, data);
      }
      if (selectionStart.position < decimalIndex) {
        intMask.handleCursor(selectionStart, selectionEnd, oldTokens, newTokens, data);
      } else {
        decimalMask.handleCursor(selectionStart, selectionEnd, oldTokens, newTokens, data);
      }
    },
    unformat: (text, tokens) => {
      const [int = 0, decimal2 = 0] = text.replace(/ /g, "").split(decimalChar);
      return parseFloat(int + "." + decimal2).toString();
    }
  };
};
export {
  createNumeralMask as c
};
//# sourceMappingURL=numeral.js.map
